# OAuth是什么

OAuth的英文全称是Open Authorization，它是一种开放授权协议。

OAuth 2.0是行业标准的授权协议。专注于客户端开发人员的简单性，同时为Web应用程序，桌面应用程序，移动电话和客厅设备提供特定的授权流程。

## 解决什么问题

传统的客户端--服务器身份验证模式中，客户端访问服务器上限制访问资源时，需要在服务器上验证资源所有者的凭证。

资源所有者为第三方提供受限资源访问，需要与第三方共享它的凭证。会造成以下的问题：

* 需要第三方应用存储资源所有者的凭据，以供将来使用，通常是明文密码。
* 需要服务器支持密码身份认证，尽管密码认证天生就有安全缺陷。
* 第三方应用获得的资源所有者的受保护资源的访问权限过于宽泛，从而导致资源所有者失去对资源使用时限或使用范围的控制。
* 资源所有者不能仅撤销某个第三方的访问权限而不影响其它，并且，资源所有者只有通过改变第三方的密码，才能单独撤销这第三方的访问权限。
* 与任何第三方应用的让步导致对终端用户的密码及该密码所保护的所有数据的让步。

简单概括，就是用于第三方在用户授权下调取平台对外开放接口获取用户相关信息。

OAuth通过引入授权层以及分离客户端角色和资源所有者角色来解决这些问题。

第三方应用请求受保护的资源时，服务器在经过资源用户授权后，会向第三方客户端颁发一个访问令牌(AccessToken)。该令牌包含了资源所有者授权访问的返回、授权有效期等关键属性。第三方客户端在后续的资源访问中，需要一直持有此令牌，直到用户终止或者令牌过期。

比如：授权微信登录某个应用时，经过用户授权后，应用可以从微信获取用户的基本信息。而无需用户输入用户名、密码。

# 名词释义

## 角色

OAuth定义了四种角色

### 资源所有者

能够许可受保护资源访问权限的实体。当资源所有者是个人时，可以理解为用户。

### 资源服务器

存放资源的服务器，能够接受和响应使用访问令牌对受保护资源的请求。理解为要访问的`应用/系统`

### 客户端

使用资源所有者的授权代表资源所有者发起对受保护资源请求的应用程序。`第三方应用`

### 授权服务器

用来验证资源所有者且获得授权后向客户端颁发访问令牌的的服务器。理解为：`认证服务器`。授权服务器可以单独部署，也可以和资源服务器部署在同一台机器上。一个授权服务器可以颁发多个资源服务器的访问令牌。

## 协议流程

```
 +--------+                               +---------------+
 |        |--(A)- Authorization Request ->|   Resource    |
 |        |                               |     Owner     |
 |        |<-(B)-- Authorization Grant ---|               |
 |        |                               +---------------+
 |        |
 |        |                               +---------------+
 |        |--(C)-- Authorization Grant -->| Authorization |
 | Client |                               |     Server    |
 |        |<-(D)----- Access Token -------|               |
 |        |                               +---------------+
 |        |
 |        |                               +---------------+
 |        |--(E)----- Access Token ------>|    Resource   |
 |        |                               |     Server    |
 |        |<-(F)--- Protected Resource ---|               |
 +--------+                               +---------------+
 OAuth2官网的协议流程
```

![1545979069108](OAuth2.assets/1545979069108.png)

上图展示了OAuth2抽象流程，描述了四个角色之前的交互。包含以下的步骤

1. 用户打开客户端以后，客户端要求用户给予授权。。两种方式：
   1. 客户端发起请求。
   2. 授权服务器发起请求。
2. 用户同意给予客户端授权。
3. 客户端使用上一步获得的授权，向认证服务器申请令牌。
4. 认证服务器对客户端进行认证以后，确认无误，同意发放令牌。
5. 客户端使用令牌，向资源服务器申请获取资源。
6. 资源服务器确认令牌无误，同意向客户端开放资源。

> 客户端用于从资源所有者获得授权许可（步骤1和2所示）的更好方法是使用授权服务器作为中介。

## 授权许可类型

授权许可是一个代表资源所有者授权(访问受保护资源)的凭证，客户端使用它来获取访问令牌。

OAuth2定义了四种许可类型：授权码、简化模式、密码模式和客户端凭据以及用户定义其他类型的可扩展机制。

### 授权码

授权码模式（authorization code）是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与"服务提供商"的认证服务器进行互动。

![ææç æ¨¡å¼](OAuth2.assets/bg2014051204.png)

步骤如下：

> （A）用户访问客户端，后者将前者导向认证服务器。
>
> （B）用户选择是否给予客户端授权。
>
> （C）假设用户给予授权，认证服务器将用户导向客户端事先指定的"重定向URI"（redirection URI），同时附上一个授权码。
>
> （D）客户端收到授权码，附上早先的"重定向URI"，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。
>
> （E）认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。



#### 参数

A步骤中，客户端申请认证的URI，包含以下参数：

- response_type：表示授权类型，必选项，此处的值固定为"code"
- client_id：表示客户端的ID，必选项
- redirect_uri：表示重定向URI，可选项
- scope：表示申请的权限范围，可选项
- state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。

```http
GET /authorize?response_type=code&client_id=s6BhdRkqt3&state=xyz
        &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
Host: server.example.com
```

C步骤中，服务器回应客户端的URI，包含以下参数：

- code：表示授权码，必选项。该码的有效期应该很短，通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端ID和重定向URI，是一一对应关系。
- state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。

下面是一个例子。

> ```http
> HTTP/1.1 302 Found
> Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA
>           &state=xyz
> ```



D步骤中，客户端向认证服务器申请令牌的HTTP请求，包含以下参数：

- grant_type：表示使用的授权模式，必选项，此处的值固定为"authorization_code"。
- code：表示上一步获得的授权码，必选项。
- redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。
- client_id：表示客户端ID，必选项。

下面是一个例子。

> ```http
> POST /token HTTP/1.1
> Host: server.example.com
> Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
> Content-Type: application/x-www-form-urlencoded
> 
> grant_type=authorization_code&code=SplxlOBeZQQYbYS6WxSbIA
> &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
> ```

E步骤中，认证服务器发送的HTTP回复，包含以下参数：

- access_token：表示访问令牌，必选项。
- token_type：表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。
- expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。
- refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。
- scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。

下面是一个例子。

> ```http
>      HTTP/1.1 200 OK
>      Content-Type: application/json;charset=UTF-8
>      Cache-Control: no-store
>      Pragma: no-cache
> 
>      {
>        "access_token":"2YotnFZFEjr1zCsicMWpAA",
>        "token_type":"example",
>        "expires_in":3600,
>        "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
>        "example_parameter":"example_value"
>      }
> ```

从上面代码可以看到，相关参数使用JSON格式发送（Content-Type: application/json）。此外，HTTP头信息中明确指定不得缓存。

### 简化模式

简化模式（implicit grant type）不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了"授权码"这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。

![ç®åæ¨¡å¼](OAuth2.assets/bg2014051205.png)

它的步骤如下：

> （A）客户端将用户导向认证服务器。
>
> （B）用户决定是否给于客户端授权。
>
> （C）假设用户给予授权，认证服务器将用户导向客户端指定的"重定向URI"，并在URI的Hash部分包含了访问令牌。
>
> （D）浏览器向资源服务器发出请求，其中不包括上一步收到的Hash值。
>
> （E）资源服务器返回一个网页，其中包含的代码可以获取Hash值中的令牌。
>
> （F）浏览器执行上一步获得的脚本，提取出令牌。
>
> （G）浏览器将令牌发给客户端。

#### 参数

A步骤中，客户端发出的HTTP请求，包含以下参数：

- response_type：表示授权类型，此处的值固定为"token"，必选项。
- client_id：表示客户端的ID，必选项。
- redirect_uri：表示重定向的URI，可选项。
- scope：表示权限范围，可选项。
- state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。

```http
GET /authorize?response_type=token&client_id=s6BhdRkqt3&state=xyz
        &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
Host: server.example.com
```

C步骤中，认证服务器回应客户端的URI，包含以下参数：

- access_token：表示访问令牌，必选项。
- token_type：表示令牌类型，该值大小写不敏感，必选项。
- expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。
- scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。
- state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。

```http
HTTP/1.1 302 Found
Location: http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA
               &state=xyz&token_type=example&expires_in=3600
```

在上面的例子中，认证服务器用HTTP头信息的Location栏，指定浏览器重定向的网址。

注意，在这个网址的Hash部分包含了令牌。

根据上面的D步骤，下一步浏览器会访问Location指定的网址，但是Hash部分不会发送。接下来的E步骤，服务提供商的资源服务器发送过来的代码，会提取出Hash中的令牌。

### 密码模式

密码模式（Resource Owner Password Credentials Grant）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向"服务商提供商"索要授权。

在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。

![å¯ç æ¨¡å¼](OAuth2.assets/bg2014051206.png)

它的步骤如下：

> （A）用户向客户端提供用户名和密码。
>
> （B）客户端将用户名和密码发给认证服务器，向后者请求令牌。
>
> （C）认证服务器确认无误后，向客户端提供访问令牌。

#### 参数

B步骤中，客户端发出的HTTP请求，包含以下参数：

- grant_type：表示授权类型，此处的值固定为"password"，必选项。
- username：表示用户名，必选项。
- password：表示用户的密码，必选项。
- scope：表示权限范围，可选项。

```http
POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=password&username=johndoe&password=A3ddj3w
```

C步骤中，认证服务器向客户端发送访问令牌

```http
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

     {
       "access_token":"2YotnFZFEjr1zCsicMWpAA",
       "token_type":"example",
       "expires_in":3600,
       "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
       "example_parameter":"example_value"
     }

```

整个过程中，客户端不得保存用户的密码。



### 客户端模式

客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向"服务提供商"进行认证。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求"服务提供商"提供服务，其实不存在授权问题。

![å®¢æ·ç"¯æ¨¡å¼](OAuth2.assets/bg2014051207.png)

它的步骤如下：

> （A）客户端向认证服务器进行身份认证，并要求一个访问令牌。
>
> （B）认证服务器确认无误后，向客户端提供访问令牌。

#### 参数

A步骤中，客户端发出的HTTP请求，包含以下参数：

- grant*type：表示授权类型，此处的值固定为"client*credentials"，必选项。
- scope：表示权限范围，可选项。

```http
POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=client_credentials
```

认证服务器必须以某种方式，验证客户端身份。

B步骤中，认证服务器向客户端发送访问令牌。

```http
 HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache
     {
       "access_token":"2YotnFZFEjr1zCsicMWpAA",
       "token_type":"example",
       "expires_in":3600,
       "example_parameter":"example_value"
     }

```

## 访问令牌

客户端请求资源时，必须携带访问令牌。

访问令牌是用于访问受保护资源的凭据。访问令牌是一个代表向客户端颁发的授权的字符串。代表了访问的范围、有效期。

令牌可以表示一个用于检索授权信息的标识符或者可以访问验证的方式包含授权信息(即令牌字符串有数据和签名组成)

访问令牌提供了一个抽象层，统一了授权结构，消除了不同授权结构使用不同认证方法的弊端。

## 刷新令牌

刷新令牌由授权服务器颁发给客户端，用户当前访问令牌失效或者过期时，获取一个新的访问令牌。或者获得相等或者更小范围的访问令牌。刷新令牌是可选的。

刷新令牌是一个代表由资源所有者给客户端许可的授权的字符串。通常对客户端是不透明的。该令牌表示一个用于检索授权信息的标识符。刷新令牌不会发送到资源服务器。

**刷新过期的访问令牌**

```
+--------+                                           +---------------+
|        |--(A)------- Authorization Grant --------->|               |
|        |                                           |               |
|        |<-(B)----------- Access Token -------------|               |
|        |               & Refresh Token             |               |
|        |                                           |               |
|        |                            +----------+   |               |
|        |--(C)---- Access Token ---->|          |   |               |
|        |                            |          |   |               |
|        |<-(D)- Protected Resource --| Resource |   | Authorization |
| Client |                            |  Server  |   |     Server    |
|        |--(E)---- Access Token ---->|          |   |               |
|        |                            |          |   |               |
|        |<-(F)- Invalid Token Error -|          |   |               |
|        |                            +----------+   |               |
|        |                                           |               |
|        |--(G)----------- Refresh Token ----------->|               |
|        |                                           |               |
|        |<-(H)----------- Access Token -------------|               |
+--------+           & Optional Refresh Token        +---------------+
```

- （A）身份认证时携带授权许可的访问令牌。
- （B）授权服务器对客户端进行身份验证并验证授权许可，若有效则颁发访问令牌和刷新令牌。
- （C）客户端通过出示访问令牌向资源服务器发起受保护资源的请求。
- （D）资源服务器验证访问令牌，若有效则满足该要求。
- （E）步骤（C）和（D）重复进行，直到访问令牌到期。如果客户端知道访问令牌已过期，跳到步骤（G），否 则它将继续发起另一个对受保护资源的请求。
- （F）由于访问令牌是无效的，资源服务器返回无效令牌错误。
- （G）客户端通过与授权服务器进行身份验证并出示刷新令牌，请求一个新的访问令牌。客户端身份验证要求基于客户端的类型和授权服务器的策略。
- （H）授权服务器对客户端进行身份验证并验证刷新令牌，若有效则颁发一个新的访问令牌（和—可选地—一个新的刷新令牌）。

## TLS版本

安全传输层协议（TLS）用于在两个通信应用程序之间提供保密性和数据完整性。

该协议由两层组成： TLS 记录协议（TLS Record）和 TLS [握手协议](https://baike.baidu.com/item/%E6%8F%A1%E6%89%8B%E5%8D%8F%E8%AE%AE/4058729)（TLS Handshake）。

目前版本是TLS1.3

## HTTP重定向

客户端或授权服务器引导资源所有者的用户代理到另一个目的地址。

## 互操作性

OAuth 2.0提供了丰富的具有明确的安全性质的授权框架。

## 符号约定

本规范中的关键词“必须”、“不能”、“必需的”、“要”、“不要”、“应该”、“不应该”、“推荐的”、“可以”以及“可选的”按[RFC2119](http://tools.ietf.org/html/rfc2119)所述解释。
本规范使用[RFC5234](http://tools.ietf.org/html/rfc5234)的扩展巴科斯-诺尔范式(ABNF)表示法。此外，来自“统一资源标识符（URI）：通用语法”[RFC3986](http://tools.ietf.org/html/rfc3986)的规则URI引用也包含在内。

某些安全相关的术语按照[RFC4949](http://tools.ietf.org/html/rfc4949)中定义的意思理解。这些术语包括但不限于：“攻击”、“身份认证”、“授权”、“证书”、“机密”，“凭据”，“加密”，“身份”，“记号”，“签名”，“信任”，“验证”和“核实”。

除非另有说明，所有协议参数的名称和值是大小写敏感的。

# 客户端注册

客户端注册不要求客户端与授权服务器之间的直接交互。在授权服务器支持时，注册可以依靠其他方式来建立信任关系并获取客户端的属性（如重定向URI、客户端类型）例如，注册可以使用自发行或第三方发行声明或通过授权服务器使用信任通道执行客户端发现完成。

当注册客户端时，客户端开发者应该：

- 指定的客户端类型，
- 提供它的客户端重定向URI，且
- 包含授权服务器要求的任何其他信息（如，应用名称、网址、描述、Logo图片、接受法律条款等）。

## 客户端类型

根据客户端与授权服务器安全地进行身份验证的能力OAuth定义了两种客户端类型：

* 机密客户端

  能够维持其凭据机密性（如客户端执行在具有对客户端凭据有限访问权限的安全的服务器上），或者能够使用 其他方式保证客户端身份验证的安全性。

* 公开客户端

  不能够维持其凭据的机密性（如客户端执行在由资源所有者使用的设备上，例如已安装的本地应用程序或基于Web浏览器的应用），且不能通过其他方式保证客户端身份验证的安全性。
  客户端类型的选择基于授权服务器的安全身份认证定义以及其对客户端凭据可接受的暴露程度。授权服务器不应该对客户端类型做假设。

客户端可以以分布式的组件集合实现，每一个组件具有不同的客户端类型和安全上下文（例如，一个同时具有机密的基于服务器的组件和公开的基于浏览器的组件的分布式客户端）。如果授权服务器不提供对这类客户端的支持，或不提供其注册方面的指导，客户端应该注册每个组件为一个单独的客户端。
本规范围绕下列客户端配置涉及：

- Web应用程序
  Web应用是一个运行在Web服务器上的机密客户端。资源所有者通过其使用的设备上的用户代理里渲染的HTML用户界面访问客户端。客户端凭据以及向客户端颁发的任何访问令牌都存储在Web服务器上且不会暴露给资源所有者或者被资源所有者可访问。
- 基于用户代理的应用
  基于用户代理的应用是一个公开客户端，客户端的代码从Web服务器下载，并在资源所有者使用的设备上的用户代理（如Web浏览器）中执行。协议数据和凭据对于资源所有者是可轻易访问的（且经常是可见的）。由于这些应用驻留在用户代理内，在请求授权时它们可以无缝地使用用户代理的功能。
- 本机应用程序
  本机应用是一个安装、运行在资源所有者使用的设备上的公开客户端。协议数据和凭据对于资源所有者是可访问的。假定包含在应用程序中的任何客户端身份认证凭据可以被提取。另一方面，动态颁发的如访问令牌或者刷新令牌等凭据可以达到可接受的保护水平。至少，这些凭据被保护不被应用可能与之交互的恶意服务器接触。在一些平台上，这些凭证可能被保护免于被驻留在相同设备上的其他应用接触。

## 客户端标识

授权服务器颁发给已注册客户端的标识。代表客户端提供注册信息的唯一字符串。它暴露给资源所有者，并且不能单独用于客户端身份认证。

授权服务器应记录其发放的客户端标识。

## 客户端认证

如果客户端类型是机密的，客户端和授权服务器建立符合授权服务器安全性要求的客户端身份认证方法。授权服务器可以接受任何符合其安全性要求的任何形式的客户端身份验证。

机密客户端通常颁发（或建立）一组客户端凭据用于与授权服务器进行身份验证（例如，密码、公/私钥对）。

授权服务器可以和公开客户端简历客户端认证方法，但是授权服务器不能依靠公开客户端身份验证来达到识别客户端的目的。

客户端在每次请求中不能使用多个身份认证方法。

### 客户端密码

> 拥有客户端密码的客户端可以使用[RFC2617](http://tools.ietf.org/html/rfc2617)中定义的HTTP基本身份验证方案与授权服务器进行身份验证。客户端标识使用按照[附录B](https://colobu.com/2017/04/28/AppendixB/b.md)的“application/x-www-form-urlencoded”编码算法编码，编码后的值用作用户名；客户端密码使用相同的算法编码并用作密码。授权服务器必须支持HTTP基本身份验证方案，用于验证被颁发客户端密码的客户端的身份。例如（额外的换行仅用于显示目的）：

Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3

此外，授权服务器可以使用下列参数支持在请求正文中包含客户端凭据：

- client_id
  必需的。注册过程中颁发给客户端的客户端标识。
- client_secret
  必需的。客户端密钥。 客户端可以忽略该参数若客户端密钥是一个空字符串。

例如:使用请求正文参数请求刷新访问令牌

```http
 POST /token HTTP/1.1
 Host: server.example.com
 Content-Type: application/x-www-form-urlencoded
 grant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA&client_id=s6BhdRkqt3&client_secret=7Fjfp0ZBr1KtDRbnfVdmIw
```

当使用密码身份验证发送请求时，授权服务器必须要求使用TLS。

由于该客户端身份验证方法包含密码，授权服务器必须保护所有使用到密码的端点免受暴力攻击。

### 其它身份验证方法

授权服务器可以支持任何与其安全要求匹配的合适的HTTP身份验证方案。当使用其他身份验证方法时，授权服务器必须定义客户端标识（注册记录）和认证方案之间的映射。

## 未注册客户端

本规范不排除使用未注册的客户端。然而，使用这样的客户端超出了本规范的范围，并需要额外的安全性分析并审查其互操作性影响。

# 协议端点

授权过程采用了两种授权服务器端点（HTTP资源）：

- 授权端点——客户端用其通过用户代理重定向从资源所有者获取授权。
- 令牌端点——客户端用其将授权许可交换为访问令牌，通常伴有客户端身份验证。

以及一种客户端端点：

- 重定向端点——授权服务器用其通过资源所有者用户代理向客户端返回含有授权凭据的响应。

并不是每种授权许可类型都采用两种端点。

扩展许可类型可以按需定义其他端点。

## 授权端点

> 授权端点用于与资源所有者交互获取授权许可。 授权服务器必须先验证资源所有者的身份。 
>
> 授权服务器对资源所有者进行身份验证的方式（例如，用户名和密码登录、会话cookies）

由于向授权端点的请求引起用户身份验证和明文凭据传输（在HTTP响应中），当向授权端点发送请求时，授权服务器必须要求使用TLS。

必须忽略在请求中没有值的参数，授权服务器必须忽略不能识别的请求参数。请求和相应参数不能包含超过一次。

### 响应类型

授权端点被授权码许可类型和隐式许可类型流程使用。客户端使用下列参数通知授权服务器期望的许可类型：

- response_type
  必需的。
  - 请求授权码时：其值必须是`code`。
  - 请求访问令牌时其值必须时：`token`。
  - 或者是自定扩展值的其中一个。

扩展响应类型可以包含一个空格（%x20）分隔的值的列表，值的顺序并不重要（例如，响应类型“a b”与“b a”相同）。 这样的复合响应类型的含义由他们各自的规范定义。

如果授权请求缺少“response_type”参数，或者如果响应类型不被理解，授权服务器必须返回一个错误响应。

### 重定向端点

授权完成后，授权服务器会进行URL重定向，将返回客户端。该URL是客户端事前注册时或者发起授权时携带的重定向URL。

重定向URL：必须是[RFC3986的3.4节](http://tools.ietf.org/html/rfc3986#section-3.4)所述的绝对URI。

#### 端点请求的机密性

当请求的相应类型是`code`或`token`时，或者当重定向请求将敏感凭证在开放网络中传输时，重定向端点应该使用TLS。如果TLS不可用，授权服务器应该在重定向之前清高资源所有者有关非安全端点重定向信息（例如，在授权期间显示消息）。

缺乏传输层安全时，可能对客户端及它被授权访问的受保护资源的安全具有严重影响。当授权过程用作一种客户端委托的对最终用户认证（例如，第三方登录服务）的形式时，使用传输层安全尤其关键。

#### 注册要求

授权服务器必须要求以下客户端，注册他们的重定向端点：

- 公开客户端。
- 采用隐式许可类型的机密客户端。

授权服务器应该要求所有客户端在使用授权端点前注册它们的重定向端点。

授权服务器应该要求客户端提供完整的重定向URI（客户端可以使用“state”请求参数实现每请求自定义）。如果要求完整的重定向URI注册不可行，授权服务器应该要求注册URI方案、授权和路径（当请求授权时只允许客户端动态改变重定向URI的查询部分）。

授权服务器可以允许客户端注册多个重定向端点。

#### 动态配置

如果多个重定向URI被注册，或者如果只有部分重定向URI被注册，或者如果没有重定向URI被注册，客户端都必须使用“redirect_uri”请求参数在授权请求中包含重定向URI。

当重定向URI被包含在授权请求中时，若有任何重定向URI被注册，授权服务器必须将接收到的值与至少一个已注册的重定向URI（或URI部分）按[RFC3986第6节](http://tools.ietf.org/html/rfc3986#section-6)所述进行比较并匹配。如果客户端注册包含了完整的重定向URI，授权服务器必须使用[RFC3986第6.2.1节](http://tools.ietf.org/html/rfc3986#section-6.2.1)中定义的简单字符串比较法比对这两个URI 。

#### 无效端点

如果由于缺失、无效或不匹配的重定向URI而验证失败，授权服务器应该通知资源所有者该错误且不能向无效的重定向URI自动重定向用户代理。

#### 端点内容

向客户端端点的重定向请求通常会引起由用户代理处理的HTML文档响应。如果HTML相应直接作为重定向请求的服务结果，任何包含在HTML文档中的脚本执行，并具有对重定向URI和其包含的凭据的完全访问权限。

客户端不应该在重定向端点的响应中包含任何第三方的脚本（例如：第三方分析、社交插件、广告网络）。如果包含第三方脚本，客户端必须确保它自己的脚本先执行。

## 令牌端点

客户端通过提交它的授权许可或刷新令牌使用令牌端点获取访问令牌。令牌端点被用于除了隐式许可类型（因为访问令牌是直接颁发的）外的每种授权许可中。

由于向令牌端点的请求引起明文凭据的传输（在HTTP请求和响应中），当向令牌端点发送请求时，授权服务器必须要求使用TLS。

当发起访问令牌请求时，客户端必须使用HTTP“POST”方法。

忽略请求中没有值的参数。授权服务器必须忽略不能识别的请求参数。请求和响应参数不能包含超过一次。

### 客户端身份认证

在向令牌端点发起请求时，机密客户端或者其他被办法客户端凭证的客户端必须和授权服务器进行身份认证。

* 请求授权码和刷新令牌时。当授权码在不安全通道上想重定向端点传输时，或者重定向URI没有注册时，客户单身份验证是关键的。
* 禁用客户端或者改变被入侵客户端的凭证，防止攻击者滥用被盗的刷新令牌。改变单套客户端凭证比撤销一套刷新凭证要快。
* 定期刷新凭证，实现身份验证管理的最佳实践。刷新单组客户端凭证比刷新整套刷新令牌速度快、消耗资源少。

在向令牌端点发送请求时，客户端可以使用“client_id”请求参数标识自己。向令牌端点的“authorization_code”和“grant_type”请求中，未经身份验证的客户端必须发送它的“client_id”，以防止自己无意中接受了本打算给具有另一个“client_id”的客户端的代码。这保护了客户端免于被替换认证码。

## 访问令牌范围

授权端点和令牌端点允许客户端使用“scope”请求参数指定访问请求的范围。反过来，授权服务器使用“scope”响应参数通知客户端颁发的访问令牌的范围。

范围参数的值表示为以空格分隔，大小写敏感的字符串。 由授权服务器定义该字符串。如果该值包含多个空格分隔的字符串，他们的顺序并不重要且每个字符串为请求的范围添加一个额外的访问区域。

> scope = scope-token *( SP scope-token )
> scope-token = 1*( %x21 / %x23-5B / %x5D-7E )

基于授权服务器的策略或资源拥有者的指示，授权服务器可以全部或部分地忽略客户端请求的范围。如果颁发的访问令牌范围和客户端请求的范围不同，授权服务器必须包含“scope”响应参数通知客户端实际许可的范围。

在请求授权时如果客户端忽略了范围参数，授权服务器必须要么使用预定义的默认值处理请求，要么使请求失败以指出无效范围。授权服务器应该记录它的范围需求和默认值（如果已定义）。

# 颁发访问令牌

如果访问令牌请求是有效且被授权的，授权服务器颁发访问令牌及可选的刷新令牌。如果客户端身份验证失败或者无效，授权服务器返回错误响应。

## 成功响应

授权服务器颁发访问令牌和可选的刷新令牌，通过向HTTP响应实体正文中添加下列参数并使用200（OK）状态码构造响应：

- access_token
  必需的。授权服务器颁发的访问令牌。
- token_type
  必需的。颁发的令牌的类型。值是大小写敏感的。
- expires_in
  推荐的。以秒为单位的访问令牌生命周期。例如，值“3600”表示访问令牌将在从生成响应时的1小时后到期。如果省略，则授权服务器应该通过其他方式提供过期时间，或者记录默认值。
- refresh_token
  可选的。刷新令牌，可以用于使用相同的授权许可获得新的访问令牌。
- scope
  可选的，若与客户端请求的范围相同；否则，必需的。如访问令牌的范围。

这些参数使用[RFC4627](http://tools.ietf.org/html/rfc4627)定义的“application/json”媒体类型包含在HTTP响应实体正文中。参数顺序无关并可以变化。

在任何包含令牌、凭据或其他敏感信息的响应中，授权服务器必须在其中包含值为“no-store”的HTTP“Cache-Control”响应头部域[RFC2616](http://tools.ietf.org/html/rfc2616)，和值为“no-cache”的“Pragma”响应头部域[RFC2616](http://tools.ietf.org/html/rfc2616)。例如：

```http
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache
{
  "access_token":"2YotnFZFEjr1zCsicMWpAA",
  "token_type":"example",
  "expires_in":3600,
  "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
  "example_parameter":"example_value"
}
```

客户端必须忽略相映红不能识别的值的名称。客户端应该避免对值的大小做假设。授权服务器应记录其发放的任何值的大小。

## 错误响应

授权服务器使用HTTP 400（错误请求）状态码响应，在响应中包含下列参数：

- error
  必需的。下列ASCII[USASCII]错误代码之一：

  - invalid_request
    请求缺少必需的参数、包含不支持的参数值（除了许可类型）、重复参数、包含多个凭据、采用超过一种客户端身份验证机制或其他不规范的格式。
  - invalid_client
    客户端身份验证失败（例如，未知的客户端，不包含客户端身份验证，或不支持的身份验证方法）。授权服务器可以返回HTTP 401（未授权）状态码来指出支持的HTTP身份验证方案。如果客户端试图通过“Authorization”请求标头域进行身份验证，授权服务器必须响应HTTP 401（未授权）状态码，并包含与客户端使用的身份验证方案匹配的“WWW-Authenticate”响应标头字段。
  - invalid_grant
    提供的授权许可（如授权码、资源所有者凭据）或刷新令牌无效、过期、吊销、与在授权请求使用的重定向URI不匹配或颁发给另一个客户端。
  - unauthorized_client
    进行身份验证的客户端没有被授权使用这种授权许可类型。
  - unsupported_grant_type
    授权许可类型不被授权服务器支持。
  - invalid_scope
    请求的范围无效、未知的、格式不正确或超出资源所有者许可的范围。

  “error”参数的值不能包含集合％x20-21 /％x23-5B /％x5D-7E以外的字符。

- error_description
  可选的。提供额外信息的人类可读的ASCII[USASCII]文本，用于协助客户端开发人员理解所发生的错误。“error_description”参数的值不能包含集合％x20-21 /％x23-5B /％x5D-7E以外的字符。

- error_uri
  可选的。指向带有有关错误的信息的人类可读网页的URI，用于提供客户端开发人员关于该错误的额外信息。“error_uri”参数值必须符合URI参考语法，因此不能包含集合％x21/%x23-5B /％x5D-7E以外的字符。

这些参数使用[RFC4627](http://tools.ietf.org/html/rfc4627)定义的“application/json”媒体类型包含在HTTP响应实体正文中。

```http
HTTP/1.1 400 Bad Request
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache
{
  "error":"invalid_request"
}
```

# 刷新访问令牌

如果授权服务器给客户端颁发了刷新令牌，客户端发起刷新请求时必须将`Content-Type`设置为`application/x-www-form-urlencoded`,请求参数必须是UTF-8编码格式。参数如下：

- grant_type
  必需的。值必须设置为“refresh_token”。
- refresh_token
  必需的。颁发给客户端的刷新令牌。
- scope
  可选的。访问请求的范围。请求返回必须小于等于原始许可的范围，若省略，被视为与资源所有者原始许可的范围相同。

因为刷新令牌通常是请求额外的访问令牌的持久凭证，刷新令牌必须绑定到请求的客户端。客户端必须与授权服务器进行身份认证。

例如，客户端使用传输层安全发起如下HTTP请求（额外的换行仅用于显示目的）：

```http
POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded
grant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA
```

授权服务器必须：

- 要求机密客户端或任何被颁发了客户端凭据（或有其他身份验证要求）的客户端进行客户端身份验证，
- 若包括了客户端身份验证，验证客户端身份并确保刷新令牌是被颁发给进行身份验证的客户端的
- 验证刷新令牌。

如果有效且被授权，颁发访问令牌，否则返回错误响应。

如果授权服务器颁发新的刷新令牌，客户端必须替换旧的刷新令牌。若颁发了新的刷新令牌，其范围必须与客户端包含请求中的刷新令牌范围相同。

# 访问受保护的资源

通过向资源服务器出示访问令牌，客户端可以访问受保护资源。资源服务器必须验证访问令牌，确保其有效期、范围。一般是资源服务器向授权服务器进行验证。

客户端使用访问令牌与资源服务器进行认证的方法依赖于授权服务器颁发的访问令牌类型。通常，它涉及到使用具有所采用的访问令牌类型的规范定义的身份验证方案(如[RFC6750](http://tools.ietf.org/html/rfc6750))的HTTP“Authorization”的请求标头字段[RFC2617](http://tools.ietf.org/html/rfc2617)。

## 访问令牌类型

访问令牌的类型给客户端提供了成功使用该访问令牌（和类型指定的属性）发起受保护资源请求所需的信息 若客户端不理解令牌类型，则不能使用该访问令牌。

例如，[RFC6750](http://tools.ietf.org/html/rfc6750)定义的“bearer”令牌类型简单的在请求中包含访问令牌字符串来使用：

```http
GET /resource/1 HTTP/1.1
Host: example.com
Authorization: Bearer F_9.B5f-4.1JqM
```

而[OAuth-HTTP-MAC]定义的“mac”令牌类型通过与许可类型一起颁发用于对HTTP请求中某些部分签名的消息认证码（MAC）的密钥来使用。

```http
GET /resource/1 HTTP/1.1
Host: example.com
Authorization: MAC id="h480djs93hd8",nonce="274312:dj83hs9s",mac="kDZvddkndxvhGRXZhvuDjEWhGeE="
```

提供上面的例子仅作说明用途。

每一种访问令牌类型的定义指定与“access_token”响应参数一起发送到客户端的额外属性。它还定义了HTTP验证方法当请求受保护资源时用于包含访问令牌。

## 错误响应

如果资源访问请求失败，资源服务器应该通知客户端该错误。

# 本机应用程序

本机应用程序是安装和执行在资源所有者使用的设备上的客户端（例如，桌面程序，本机移动应用）。本机应用程序需要关于安全、平台能力和整体最终用户体验的特别注意事项。

授权端点需要在客户端和资源所有者用户代理之间进行交互。本机应用程序可以调用外部的用户代理，或在应用程序中嵌入用户代理。例如：



